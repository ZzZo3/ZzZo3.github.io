# ITERATIVE FUNCTIONS
iterate p( n type ints , k type ints , E type { out } , i type any p) type any = [ out = i , [ E , n = n + 1 ] while k >=? n ]
  # n: starting step value
  # k: ending step value
  # E: expression vector to iterate over
  # i: starting value for output
sum p(  n type ints , k type { ints >= n } , E type { out } p) type comps = iterate ( n , k , E = [ out = out + E ] , 0 )
  # summation
prod p(  n type ints , k type { ints >= n } , E type { out } p) type comps = iterate ( n , k , E = [ out = out * E ] , 0 )
  # production
derange p( x type nats p) type nats = iterate ( 2 , x , E = [ out = n * out + -1 ^ n ] , 0 )
  # derangement

# IF and OPERATOR FUNCTIONS
if p( E type { out } , C p) = [ c = 0 , [ E , c = c + 1 ] while C + c ]
  # if statement - while loop that prevents its own second iteration
copol p( x type reals , z type reals p) type { 0 , 1 } = [ out = 0 , out = 1 if x * z >? 0 , out = 0 if x =? 0 + z =? 0 =? 2 ]
  # copolarity - returns 0 unless inputs share polarity 
  # 0 copol 0 -> 1 
